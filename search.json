[{"title":"数据结构-链表旋转","url":"http://dreamwuhi.github.io/2016/04/13/数据结构-链表旋转/","content":"<hr>\n<h1 id=\"链表旋转\"><a href=\"#链表旋转\" class=\"headerlink\" title=\"链表旋转\"></a>链表旋转</h1><p>链表旋转有指定一段旋转，也有整个链表旋转。我这边讲述下整个链表旋转，因为核心的思想都是一样的。</p>\n<h2 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h2><p>构建三个指针head,pre,cur。<br>其中，head-&gt;next指向我们待旋转链表的头结点。pre指向头结点。cur指向第二个结点。<br>每一次的操作都是一样的，如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp = head-&gt;next;</span><br><span class=\"line\">pre-&gt;next = cur-&gt;next;</span><br><span class=\"line\">head-&gt;next = cur;</span><br><span class=\"line\">cur-&gt;next = tmp;</span><br><span class=\"line\">cur = pre-&gt;next;</span><br></pre></td></tr></table></figure></p>\n<p>理解了上面的核心代码，链表旋转就完成一大半了，剩下要做的就是让链表循环起来及一些边界条件的判断，如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> ListNode* next;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> n) : val(n) , next(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reserve</span><span class=\"params\">(ListNode* root)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!root || !root-&gt;next) return root;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ListNode* head = new ListNode(<span class=\"number\">-1</span>);  <span class=\"comment\">//新建一个结点指向我们待旋转链表的头结点</span></span><br><span class=\"line\">    head-&gt;next = root;</span><br><span class=\"line\">    ListNode* pre = root;</span><br><span class=\"line\">    ListNode* cur = root-&gt;next;</span><br><span class=\"line\">    ListNode* tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp = head-&gt;next;</span><br><span class=\"line\">        pre-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        head-&gt;next = cur;</span><br><span class=\"line\">        cur-&gt;next = tmp;</span><br><span class=\"line\">        cur = pre-&gt;next;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = head-&gt;next;   </span><br><span class=\"line\">    <span class=\"keyword\">delete</span> head;\t\t<span class=\"comment\">//旋转完，释放新建的结点，防止内存泄露</span></span><br><span class=\"line\">    head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    return tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>关于链表的一些操作其实还是算简单的，只要搞清楚了链表结点之间的指向关系，一般都可以搞定~~</p>\n<hr>\n"},{"title":"多线程同步之内核模式","url":"http://dreamwuhi.github.io/2016/04/12/多线程同步之内核模式/","content":"<hr>\n<p>本文主要是对内核模式下的多线程机制进行讲述。与用户模式下的同步机制相比，使用内核对象的同步机制用途更加广泛。</p>\n<hr>\n<hr>\n<h1 id=\"内核对象包括以下几类\"><a href=\"#内核对象包括以下几类\" class=\"headerlink\" title=\"内核对象包括以下几类\"></a>内核对象包括以下几类</h1><ul>\n<li>进程</li>\n<li>线程</li>\n<li>作业</li>\n<li>事件</li>\n<li>可等待的计时器</li>\n<li>信号量</li>\n<li>互斥量</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"等待函数\"><a href=\"#等待函数\" class=\"headerlink\" title=\"等待函数\"></a>等待函数</h1><p>在使用内核对象的同步机制时，就要用到等待函数来判断内核对象是否已经触发，这样就可以确定调用线程是否可被调度。</p>\n<h2 id=\"WaitForSingleObject\"><a href=\"#WaitForSingleObject\" class=\"headerlink\" title=\"WaitForSingleObject\"></a>WaitForSingleObject</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">WaitForSingleObject</span><span class=\"params\">(HANDLE hObject, DWORD dwMilliseconds)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>hObject：表示要等待的内核对象</li>\n<li>dwMilliseconds：表示线程愿意花费多少时间来等待对象被触发（时间单位：毫秒），INFINITE表示无限等待  </li>\n<li>函数的返回值：如果线程等待的对象被触发了，则返回WAIT_object_0; 如果因为等待超时，返回WAIT_TIMEOUT; 如果给函数传入的是无限的句柄，则返回WAIT_FAILED;</li>\n</ul>\n<h2 id=\"WaitForMultipleObject\"><a href=\"#WaitForMultipleObject\" class=\"headerlink\" title=\"WaitForMultipleObject\"></a>WaitForMultipleObject</h2><p>与WaitForSingleObject不同之处，WaitForMultipleObject可以等待多个内核对象。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">WaitForMultipleObject</span><span class=\"params\">(</span><br><span class=\"line\">\t\tDWORD dwCount,</span><br><span class=\"line\">\t\tCONST HANDLE* phObjects,</span><br><span class=\"line\">\t\tBOOL  bWaitAll, </span><br><span class=\"line\">\t\tDWORD dwMilliseconds)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dwCount：等待内核对象的数量</li>\n<li>phObjects：指针，指向内核对象句柄数组</li>\n<li>bWaitAll： TRUE,等待所有的内核对象都触发时才返回；FALSE，只要有一个内核对象触发就返回</li>\n<li>dwMilliseconds：表示线程愿意花费多少时间来等待对象被触发（时间单位：毫秒），INFINITE表示无限等待 </li>\n<li>WaitForMultipleObject的返回值：WAIT_TIMEOUT、WAIT_FAILED与WaitForSingleObject相同；如果设置的是任意一个内核对象触发就返回的话，则返回值是[WAIT_object_0,WAIT_object_0+dwCount-1]，得到的数值是内核句柄数组的一个索引；</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"事件内核对象\"><a href=\"#事件内核对象\" class=\"headerlink\" title=\"事件内核对象\"></a>事件内核对象</h1><p>事件内核对象包括一个使用计数，一个是否是自动重置事件还是手动重置事件的布尔值，以及另一个表示事件有没有被触发的布尔值。<br>手动重置事件被触发的时候，正在等待该事件的所有线程都讲变成可调度状态。<br>自动重置事件被触发的时候，只要一个正在等待该事件的线程会变成可调度状态。</p>\n<h2 id=\"事件内核对象的创建\"><a href=\"#事件内核对象的创建\" class=\"headerlink\" title=\"事件内核对象的创建\"></a>事件内核对象的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">CreateEvent</span><span class=\"params\">(</span><br><span class=\"line\">\t\tPSECURITY_ATTRIBUTES psa,</span><br><span class=\"line\">\t\tBOOL bManualReset,</span><br><span class=\"line\">\t\tBOOL bInitialState,</span><br><span class=\"line\">\t\tPCTSTR pszName)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>bManualReset:表示是否创建手动重置对象</li>\n<li>bInitialState:事件初始化为触发状态(TRUE)还是未触发状态(FALSE)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">SetEvent</span><span class=\"params\">(HANDLE hEvent)</span></span>;<span class=\"comment\">//设置事件触发状态</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">ResetEvent</span><span class=\"params\">(HANDLE hEvent)</span></span>;<span class=\"comment\">//设置事件未触发状态</span></span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<h1 id=\"信号量内核对象\"><a href=\"#信号量内核对象\" class=\"headerlink\" title=\"信号量内核对象\"></a>信号量内核对象</h1><p>信号量内核对象用来对资源进行计数。包含一个使用计数，一个最大资源计数和一个目前资源使用计数。</p>\n<h2 id=\"信号量的规则：\"><a href=\"#信号量的规则：\" class=\"headerlink\" title=\"信号量的规则：\"></a>信号量的规则：</h2><ul>\n<li>如果当前资源计数大于0，那么信号量处于触发状态</li>\n<li>如果当前资源计数等于0，那么信号量处于未触发状态</li>\n<li>系统绝对不会让当前资源计数变为负数</li>\n<li>当前资源计数绝对不会大于最大资源计数</li>\n</ul>\n<h2 id=\"信号量内核对象的创建\"><a href=\"#信号量内核对象的创建\" class=\"headerlink\" title=\"信号量内核对象的创建\"></a>信号量内核对象的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">CreateSemaphore</span><span class=\"params\">(</span><br><span class=\"line\">\t\tPSECURITY_ATTRIBUTES psa,</span><br><span class=\"line\">\t\tLONG lInitialCount,</span><br><span class=\"line\">\t\tLONG lMaximumCount,</span><br><span class=\"line\">\t\tPCTSTR pszName)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lMaximumCount: 资源的最大使用数量</li>\n<li>lInitialCount: 初始化时资源中有多少可以使用</li>\n</ul>\n<p>每当线程成功等待信号量内核对象，则会将当前使用计数减1，最后线程还要调用ReleaseSemaphore来递增信号量的当前资源使用计数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">ReleaseSemaphore</span><span class=\"params\">(HANDLE hSemaphore,LONG lReleaseCount,PLONG plRreviousCount)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//此函数把lReleaseCount的值加到信号量的当前资源计数上，plRreviousCount返回当前资源计数的原始值</span></span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<h1 id=\"互斥量内核对象\"><a href=\"#互斥量内核对象\" class=\"headerlink\" title=\"互斥量内核对象\"></a>互斥量内核对象</h1><p>互斥量内核对象用来确保一个一个线程独占对一个资源的访问。互斥量对象包含一个使用计数，线程ID，递归计数。<br>其中，线程ID用了标识当前占用互斥量的是系统中的哪一个线程，递归计数标识这个线程占用该互斥量的次数。</p>\n<h2 id=\"互斥量对象的规则：\"><a href=\"#互斥量对象的规则：\" class=\"headerlink\" title=\"互斥量对象的规则：\"></a>互斥量对象的规则：</h2><ul>\n<li>如果线程ID为0，那么该互斥对象不为任何线程所占用，它处于触发状态</li>\n<li>如果线程ID非零值，那么有一个线程已经占用了该互斥量，它处于未触发状态</li>\n</ul>\n<h2 id=\"互斥量对象的创建\"><a href=\"#互斥量对象的创建\" class=\"headerlink\" title=\"互斥量对象的创建\"></a>互斥量对象的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">CreateMutex</span><span class=\"params\">(</span><br><span class=\"line\">\t\tPSECURITY_ATTRIBUTES psa,</span><br><span class=\"line\">\t\tBOOL bInitialOwner,</span><br><span class=\"line\">\t\tPCTSTR pszName)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>bInitialOwner: 互斥量对象的初始状态。FALSE,互斥量对象的线程ID为0，递归计数为0，处于触发状态。<br>互斥内核对象的一个特点：系统会检查当前线程的ID与互斥量内部记录的线程ID是否相同。如果ID一致，那么系统会让线程保持可调度状态，即使互斥量尚未触发。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">ReleaseMutex</span><span class=\"params\">(HANDLE hMutex)</span></span>;<span class=\"comment\">//释放互斥量，互斥量内部的线程ID置0，递归计数置0，互斥量变成触发状态</span></span><br></pre></td></tr></table></figure>\n<hr>\n"},{"title":"多线程同步","url":"http://dreamwuhi.github.io/2016/04/11/多线程同步/","content":"<hr>\n<p>本文主要讲了用户模式下的线程同步机制，用户模式下的同步最大的好处是速度快。此外还有内核状态下的同步机制将放在写一篇博客中讲述！</p>\n<h1 id=\"原子访问\"><a href=\"#原子访问\" class=\"headerlink\" title=\"原子访问\"></a><strong>原子访问</strong></h1><ul>\n<li>指的是一个线程在访问某个资源的<font color=\"red\">同时</font>能够保证没有其他线程会在同一时刻访问同一资源。<br>Interlocked系列的函数可以保证是原子操作。</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"高级线程同步\"><a href=\"#高级线程同步\" class=\"headerlink\" title=\"高级线程同步\"></a><strong>高级线程同步</strong></h1><ul>\n<li>当线程想要访问某一共享资源的时候，线程必须调用系统函数，将线程想要访问的东西作为参数传递给函数。如果操作系统检测到资源可以被访问，那么这个函数会立即返回。这样线程就编程可调度状态。如果无法访问该共享资源，那么系统会将线程切换到等待状态，使线程变得不可调度，从而避免线程浪费CPU的时间。</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"关键代码段\"><a href=\"#关键代码段\" class=\"headerlink\" title=\"关键代码段\"></a><strong>关键代码段</strong></h1><ul>\n<li>这种方式让多行代码以原子的方式对资源进行操控。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CRITICAL_SECTION g_cs \t<span class=\"comment\">//初始化关键代码段结构</span></span><br><span class=\"line\">InitializeCriticalSection(g_cs);    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">EnterCriticalSection(&amp;g_cs);    <span class=\"comment\">//进入关键代码段</span></span><br><span class=\"line\">...</span><br><span class=\"line\">LeaveCriticalSection(&amp;g_cs);    <span class=\"comment\">//离开关键代码段</span></span><br><span class=\"line\">DeleteCriticalSection(g_cs);    <span class=\"comment\">//删除</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"关键段与旋转锁\"><a href=\"#关键段与旋转锁\" class=\"headerlink\" title=\"关键段与旋转锁\"></a><strong>关键段与旋转锁</strong></h1><ul>\n<li>当线程试图进入一个关键段，但这个关键段正被另一个线程占用的时候，函数会立即把调用线程切换到等待状态。这意味着线程必须从用户模式切换到内核模式（消耗大约1000个CPU周期）。这个切换的开销非常大。在配有多处理器的机器中，当前占用资源的线程可能在另一个线程完全切换到内核状态前就释放了占用的资源。如果真发生这种情况，那么会消耗大量的CPU周期。<br>因此在关键代码段中加入旋转锁来解决此问题。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">InitializeCriticalSectionAndSpinCount</span><span class=\"params\">(PCRITICAL_SECTION pcs, DWORD dwSpinCount)</span></span>;<span class=\"comment\">//dwSpinCount 表示旋转锁循环的次数</span></span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<h1 id=\"Slim读-写锁\"><a href=\"#Slim读-写锁\" class=\"headerlink\" title=\"Slim读/写锁\"></a><strong>Slim读/写锁</strong></h1><ul>\n<li>SRWLock允许我们区分那些想要读取资源值的线程（读取者线程）和想要更新资源值的线程（写入者线程）。让所有读取者线程同一时刻访问资源是可行的，因为不会破坏数据。写入者线程应该独占资源的访问权，任何其他读取者线程与写入者线程都不允许访问该资源。这就是SRWLock锁的关不内容。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">InitializeSRWLock</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>;<span class=\"comment\">//初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//写入者线程访问</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">AcquireSRWLockExclusive</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//读</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">ReleaseSRWLockExclusive</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//释放</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取者线程访问</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">AcquireSRWLockShared</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//读</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">ReleaseSRWLockShared</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//释放</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n"},{"title":"C++基础知识(1)","url":"http://dreamwuhi.github.io/2016/04/11/C++基础知识(1)/","content":"<h3 id=\"New和Delete\"><a href=\"#New和Delete\" class=\"headerlink\" title=\"New和Delete\"></a>New和Delete</h3><ul>\n<li><p>内置类型对象或未提供默认构造函数的类类型对象必须显示初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* a = new int;\t\t//a未初始化</span><br><span class=\"line\">int* b = new int();\t\t//b初始化为0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>delete后，应该将指针赋值为NULL，否则该指针成为“悬垂指针”，悬垂指针是指向曾经存放对象的内存，但该对象已经不再存在了。</p>\n</li>\n<li>C++保证：删除0值的指针是安全的</li>\n</ul>\n<h3 id=\"显示类型转换\"><a href=\"#显示类型转换\" class=\"headerlink\" title=\"显示类型转换\"></a>显示类型转换</h3><ul>\n<li><strong>调用方式：</strong> cast-name<type>(expression)</type></li>\n<li><p><strong>static_cast</strong><br>  编译器隐式的执行任何类型转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void* p = &amp;d;</span><br><span class=\"line\">double* dp = static_cast&lt;double*&gt;p;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dynamic_cast</strong></p>\n</li>\n<li><strong>const_cast</strong><br>  转换掉表达式的const性质</li>\n<li><strong>reinterpret_cast</strong></li>\n</ul>\n<h3 id=\"类成员函数的重载\"><a href=\"#类成员函数的重载\" class=\"headerlink\" title=\"类成员函数的重载\"></a>类成员函数的重载</h3><ul>\n<li>函数名相同，函数的参数不同，返回值可以不同。注意：基于成员函数是否为const,可以重载一个成员函数</li>\n</ul>\n<h3 id=\"类的inline函数\"><a href=\"#类的inline函数\" class=\"headerlink\" title=\"类的inline函数\"></a>类的inline函数</h3><ul>\n<li>编译器会自动展开函数的定义。注意点：一般函数的代码量很小，且该函数会被经常调用。同时，该函数的定义必须被调用它的源文件可见。通常，内联函数的定义是放在某公共头文件中。</li>\n</ul>\n<h3 id=\"类的成员使用类声明\"><a href=\"#类的成员使用类声明\" class=\"headerlink\" title=\"类的成员使用类声明\"></a>类的成员使用类声明</h3><ul>\n<li>只有当类的定义已经在前面出现过数据成员才能被指定为该类类型。如果该类型是不完全类型（即只声明未定义），那么数据成员只能是指向该类类型的指针或者是引用。</li>\n</ul>\n<h3 id=\"类的构造函数初始化\"><a href=\"#类的构造函数初始化\" class=\"headerlink\" title=\"类的构造函数初始化\"></a>类的构造函数初始化</h3><ul>\n<li>构造函数的初始化列表会在构造函数体内语句之前运行。</li>\n<li>如果没有显式初始化列表，那么对于类类型的成员变量使用该成员变量的默认构造函数初始化。对于内置类型或者是复合类型的成员变量根据对象是否为全局而定。（全局对象则会初始化，局部对象不会初始化）</li>\n<li><strong>注意</strong>：对于const成员变量或者是引用类型成员变量及没有默认构造函数的类类型成员变量必须在显式初始化列表。</li>\n</ul>\n<h3 id=\"构造函数的隐式转换\"><a href=\"#构造函数的隐式转换\" class=\"headerlink\" title=\"构造函数的隐式转换\"></a>构造函数的隐式转换</h3><ul>\n<li>一般只带一个参数的构造函数会出现隐式转换，或者是构造函数的第二参数带有默认值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t A()</span><br><span class=\"line\">\t &#123;&#125;</span><br><span class=\"line\">\t A(int a)</span><br><span class=\"line\">\t &#123;</span><br><span class=\"line\">\t\tnum = a;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint num;\t \t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A a = 12 //隐式的调用构造函数，再调用复制构造函数</span><br><span class=\"line\">A b(12); //显示的调用构造函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>隐式转换一般会带来不好的影响，最好的处理方法是加上<strong>explicit</strong>关键字，指定构造函数不能隐式转换。</li>\n</ul>\n<h3 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h3><ul>\n<li>允许一个类将对其非公有成员的访问授予指定的函数或类</li>\n</ul>\n<h3 id=\"static类成员\"><a href=\"#static类成员\" class=\"headerlink\" title=\"static类成员\"></a>static类成员</h3><ul>\n<li>非static数据成员存在于类类型的每一个对象中。static数据成员独立于该类的任意对象而存在；每个static数据成员与类关联的对象，并不与类的对象关联。</li>\n<li>static成员函数只能访问static成员变量，不能直接使用非static成员变量。</li>\n</ul>\n<h3 id=\"复制构造函数\"><a href=\"#复制构造函数\" class=\"headerlink\" title=\"复制构造函数\"></a>复制构造函数</h3><ul>\n<li><p>调用时间</p>\n<ul>\n<li>根据另一个同类型的对象显示或者是隐式初始化一个对象</li>\n<li>复制一个对象，将它作为实参传给一个函数</li>\n<li>从函数返回时复制对象</li>\n<li><p>初始化顺序容器中的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::string&gt;(10);//先调用string的默认构造函数，再调用复制构造函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据元素初始化式初列表初始化数组元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a[] = &#123;std::string(&quot;abc&quot;),std::string(&quot;bca&quot;)&#125;;</span><br><span class=\"line\">//首先调用A中接受string形参的构造函数初始化一个临时对象，再调用A的复制构造函数初始化</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>具体例子</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = &quot;99999&quot;;//首先调用接受一个C风格字符串形参的构造函数，再调用复制构造函数</span><br><span class=\"line\">string empty_copy = string();//首先调用默认构造函数，再调用复制构造函数</span><br></pre></td></tr></table></figure>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><ul>\n<li>当类中含有指针成员的时候，不重写赋值构造函数，复制构造函数，析构函数的话，很容易使程序崩溃</li>\n<li><strong>原因：</strong> 编译器为我们合成的复制、赋值函数，都只是浅层拷贝，不是深层拷贝（指针指向同一个对象），因此往往会在析构的时候，出现异常。</li>\n<li><strong>解决方法1：</strong>定义智能指针，引入<strong>使用计数</strong>概念</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class U_Ptr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tfriend class HasPtr;</span><br><span class=\"line\">\tint *ip;</span><br><span class=\"line\">\tsize_t use;//使用计数</span><br><span class=\"line\">\tU_Ptr(int* p) : ip(p) , use(1) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~U_Ptr()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdelete ip;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class HasPtr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tHasPtr(int*p , int i) : ptr(new U_Ptr(p)) , val(i) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr(const HasPtr&amp; orig) : ptr(orig.ptr), val(orig.val) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tptr-&gt;use++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr&amp; operator=(const HasPtr&amp; rhs)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t++rhs.ptr-&gt;use;</span><br><span class=\"line\">\t\tif(--ptr-&gt;use == 0)</span><br><span class=\"line\">\t\t\tdelete ptr;</span><br><span class=\"line\">\t\tptr = rhs.ptr;</span><br><span class=\"line\">\t\tval = rhs.val;</span><br><span class=\"line\">\t\treturn *this;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~HasPtr()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(--ptr-&gt;use == 0)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdelete ptr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tU_Ptr *ptr;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>解决方法2”</strong>实现深层拷贝</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HasPtr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint* ptr;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tHasPtr(const int&amp; p, int i) : ptr(new int(p)) , val(i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr(const HasPtr&amp; orig) : ptr(new int(*orig.ptr)) , val(orig.val)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t//实现深拷贝</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr&amp; operator=(HasPtr&amp; rhs)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tptr = rhs.ptr;</span><br><span class=\"line\">\t\tval = rhs.val;</span><br><span class=\"line\">\t\treturn *this;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"protected成员\"><a href=\"#protected成员\" class=\"headerlink\" title=\"protected成员\"></a>protected成员</h3><ul>\n<li>基类的一些成员希望允许派生类访问但是禁止其他用户访问，对于这样的成员应使用受保护的访问标志</li>\n<li><strong>注意点：</strong>派生类只能通过派生类对象访问其基类的protected成员，派生类对其基类类型对象的protected成员没有特殊访问权限。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test_base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tTest_base()&#123;&#125;</span><br><span class=\"line\">\t~Test_base()&#123;&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint pb;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint kk;</span><br><span class=\"line\">\t/* data */</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test_sun : public Test_base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid fun(Test_sun&amp; t, Test_base&amp; base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tt.pb = 1;  //派生类对象可以访问基类的protected成员</span><br><span class=\"line\">\t\tbase.pb = 1;//错误，基类类型的对象不能访问其protected对象</span><br><span class=\"line\">\t\tpb = 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"duilib开发QQ界面","url":"http://dreamwuhi.github.io/2016/04/10/duilib开发QQ界面/","content":""},{"title":"Windows程序设计基础","url":"http://dreamwuhi.github.io/2016/04/10/Windows程序设计基础/","content":"<h2 id=\"窗口程序创建的过程\"><a href=\"#窗口程序创建的过程\" class=\"headerlink\" title=\"窗口程序创建的过程\"></a>窗口程序创建的过程</h2><hr>\n<h3 id=\"创建窗口类\"><a href=\"#创建窗口类\" class=\"headerlink\" title=\"创建窗口类\"></a>创建窗口类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WNDCLASS wndclass;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"注册窗口类\"><a href=\"#注册窗口类\" class=\"headerlink\" title=\"注册窗口类\"></a>注册窗口类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RegisterClass(&amp;wndclass);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"创建窗口\"><a href=\"#创建窗口\" class=\"headerlink\" title=\"创建窗口\"></a>创建窗口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hwnd = CreateWindow(...);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"显示窗口\"><a href=\"#显示窗口\" class=\"headerlink\" title=\"显示窗口\"></a>显示窗口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ShowWindow(hwnd,iCmdShow);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"更新窗口\"><a href=\"#更新窗口\" class=\"headerlink\" title=\"更新窗口\"></a>更新窗口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UpdateWindow(hwnd);  <span class=\"comment\">//产生第一条WM_PATINT消息</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"消息循环\"><a href=\"#消息循环\" class=\"headerlink\" title=\"消息循环\"></a>消息循环</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(GetMessage(&amp;msg,NULL,<span class=\"number\">0</span>,<span class=\"number\">0</span>))  <span class=\"comment\">//获取消息，只要消息类型不为WM_QUIT，返回值是非零值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTranslateMessgae(&amp;msg);     <span class=\"comment\">//翻译消息</span></span><br><span class=\"line\">\tDispatchMessage(&amp;msg);      <span class=\"comment\">//分发消息到窗口过程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"窗口过程\"><a href=\"#窗口过程\" class=\"headerlink\" title=\"窗口过程\"></a>窗口过程</h3><p>窗口过程在处理消息时，必须返回0。窗口过程不予处理的所有消息应该被DefWindowProc函数处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LRESULT CALLBACK <span class=\"title\">WinProctor</span><span class=\"params\">(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SendMessage(...);<span class=\"comment\">//程序可以直接调用自己的窗口过程</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结：窗口过程与一个窗口类相关联，窗口类是程序调用RegisterClass注册的。基于该类创建的窗口使用这个窗口过程来处理窗口的所有消息。Windows通过调用窗口过程来给窗口发送一个消息</strong></p>\n<hr>\n<h2 id=\"窗口消息\"><a href=\"#窗口消息\" class=\"headerlink\" title=\"窗口消息\"></a>窗口消息</h2><h3 id=\"WM-PAINT\"><a href=\"#WM-PAINT\" class=\"headerlink\" title=\"WM_PAINT\"></a>WM_PAINT</h3><p>该消息使得客户区域重绘，以下几种情况会导致客户区域重绘，即产生WM_PAINT消息。<br>1、UpdateWindow(hwnd);<br>2、放大或者是缩小窗口（窗口类风格具有CS_HREDRAW,CS_VREDRAW）。<br>3、窗口最小化后，再复原。<br>4、窗口被其他窗口覆盖后，再复原。<br>5、使用ScrollWindow或ScrollDC函数滚动客户区的一部分。<br>6、使用InvalidateRect或InvalidateRgn函数显示产生WM_PAINT消息。</p>\n<hr>\n<h3 id=\"WM-DESTROY\"><a href=\"#WM-DESTROY\" class=\"headerlink\" title=\"WM_DESTROY\"></a>WM_DESTROY</h3><p>该消息使得窗口清除关闭。一般在获取该消息后，添加PostQuitMessage(0); 即，在消息队列中添加一条WM_QUIT消息。上文提到，消息循环中当遇到WM_QUIT消息后，就退出循环，结束程序。</p>\n"},{"title":"duilib开发微信界面","url":"http://dreamwuhi.github.io/2016/04/10/duilib开发微信界面/","content":"<h2 id=\"采用Duilib开源框架开发PC端微信\"><a href=\"#采用Duilib开源框架开发PC端微信\" class=\"headerlink\" title=\"采用Duilib开源框架开发PC端微信\"></a>采用Duilib开源框架开发PC端微信</h2>"}]