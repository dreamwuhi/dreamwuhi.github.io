[{"title":"数据结构-数组去重","url":"http://dreamwuhi.github.io/2016/06/02/数据结构-数组去重/","content":"<p>给定一个数组，求去掉重复元素后数组的长度。</p>\n<p>思路:双指针，设定两个指针i,j分别指向数组的初始的两个元素，当a[i] != a[j],累加j,i保持不变。当a[i]==a[j]，累加i,将a[i]=a[j],再累加j。<br>双指针的思想，O(n)的时间复杂度。<br>举例：<br>A=[1,1,2,3,3,4]<br>(1) i=0,j=1. a[i]==a[j],j++                   数组元素未变<br>(2) i=0,j=2, a[i]!=a[j],i++,a[i]=a[j],j++. 数组变为A[1,2,2,3,3,4]<br>(3) i=1,j=3, a[i]!=a[j],i++,a[i]=a[j],j++. 数组变为A[1,2,3,3,3,4]<br>(4) i=2,j=4, a[i]==a[j],j++,               数组元素未变<br>(5) i=2,j=5, a[i]!=a[j],i++,a[i]=a[j],j++, 数组变为A[1,2,3,4,3,4]<br>(6) j=6 结束循环，此时的i+1即是去重后元素的个数。</p>\n<p>代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">RemeoveDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>*a, <span class=\"keyword\">int</span> size)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=i+<span class=\"number\">1</span>; j&lt;size; ++j)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[i] != a[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            a[++i] = a[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return i+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode-Range Sum Query 2D immutable","url":"http://dreamwuhi.github.io/2016/05/31/Leetcode-Range-Sum-Query-2D-immutable/","content":"<h3 id=\"本题题意\"><a href=\"#本题题意\" class=\"headerlink\" title=\"本题题意\"></a>本题题意</h3><p>给出一个矩阵，再给定两个坐标，分别表示子矩阵左上角与右下角的坐标，求子矩阵元素总和。<br>例如：<br>矩阵 A=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]],子矩阵左上角坐标（0，1），右下角坐标（2，3）<br>那么，sum(0,1,2,3) = 2+3+4+6+7+8+10+11+12=63</p>\n<p>思路：最直接的方法就是直接遍历子矩阵的所有元素，就可以搞定！时间复杂度为O(n^2)，但是超时了，因此需要优化。<br>受到积分图的启发，可以实现时间复杂度为O(1)!，什么！这么快。什么是积分图？<br>积分图的定义：矩阵中的某元素A的积分是矩阵左上角的顶点与A点围成的矩阵所有元素的总和。<br><a id=\"more\"></a><br>即dp[i][j] = m(0,0)+m(0,1)+m(0,2)…+m(i,j);<br>因此，第一步先计算矩阵M中所有元素的积分dp[i][j]；<br>dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+m[i][j];  (i&gt;=1,j&gt;=1)<br>dp[i][j] = dp[i][j-1] + m[i][j];  (i==0)<br>dp[i][j] = dp[i-1][j] + m[i][j];  (j==0)<br>dp[i][j] = m[i][j];     (i==j==0)<br>计算完积分图后，求子矩阵元素和，就可以直接在O(1)的时间复杂度下计算出了。<br>子矩阵的两个坐标为a(row1,col1),b(row2,col2)<br>res = dp[row2][col2] - dp[row2][col1-1] - dp[row1-1][col2] + dp[row1-1][col1-1];   (row1&gt;=1,col1&gt;=1)<br>res = dp[row2][col2]-dp[row1-1][col2];   (col1==0) //第一列<br>res = dp[row2][col2] - dp[row2][col1-1];  (row1==0) //第一行<br>res = dp[row2][col2];   (row1==col1==0)<br>注意点：考虑边缘条件，矩阵m为空。</p>\n<p>代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> NumMatrix &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> empty;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; dp;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tNumMatrix(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;matrix) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> row = matrix.size();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(row &gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tempty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> col = matrix[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">\t\t\tdp.resize(row);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;row; ++i)</span><br><span class=\"line\">\t\t\t\tdp[i].resize(col);</span><br><span class=\"line\">\t\t\tdp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>];   <span class=\"comment\">//处理原点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;col; ++j) <span class=\"comment\">//处理第一行</span></span><br><span class=\"line\">\t\t\t\tdp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j<span class=\"number\">-1</span>] + matrix[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;row; ++i)  <span class=\"comment\">//处理第一列</span></span><br><span class=\"line\">\t\t\t\tdp[i][<span class=\"number\">0</span>] = dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] + matrix[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;row; ++i)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;col; ++j)</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tdp[i][j] = dp[i][j<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-1</span>][j]-dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+matrix[i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tempty = <span class=\"literal\">true</span>;  <span class=\"comment\">//矩阵为空</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumRegion</span><span class=\"params\">(<span class=\"keyword\">int</span> row1, <span class=\"keyword\">int</span> col1, <span class=\"keyword\">int</span> row2, <span class=\"keyword\">int</span> col2)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(empty)</span><br><span class=\"line\">\t\t\treturn <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(row1==<span class=\"number\">0</span> &amp;&amp; col1==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\treturn dp[row2][col2];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(row1==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\treturn dp[row2][col2] - dp[row2][col1<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(col1==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\treturn dp[row2][col2]-dp[row1<span class=\"number\">-1</span>][col2];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\treturn dp[row2][col2] + dp[row1<span class=\"number\">-1</span>][col1<span class=\"number\">-1</span>] - dp[row2][col1<span class=\"number\">-1</span>] - dp[row1<span class=\"number\">-1</span>][col2];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode--Intersection of Two Arrays","url":"http://dreamwuhi.github.io/2016/05/31/Leetcode-Intersection-of-Two-Arrays/","content":"<h3 id=\"本题的题意\"><a href=\"#本题的题意\" class=\"headerlink\" title=\"本题的题意\"></a>本题的题意</h3><p>给定两个数组，求数组的交集。</p>\n<p>思路：假如有数组A，B，那么可以遍历数组B的元素，查看是否有在A中出现，如果有，就是交集中的一个元素。<br>注意点：<br>1、如果B中的某个元素是交集中的元素，且该元素在B中重复出现，就不要再讲其放入到交集中了，因为交集中的元素要保证唯一性。<br>可以采用std::set，先将A，B中重复的元素提前过滤掉，再讲B中元素一次插入到A中，如果插入失败，说明此元素是交集中的一元。<br><a id=\"more\"></a><br>代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; intersection(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; h1;<span class=\"comment\">//过滤A中重复的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums1.size(); ++i)</span><br><span class=\"line\">\t\t\th1.insert(nums1[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; h2;<span class=\"comment\">//过滤B中重复的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums2.size(); ++i)</span><br><span class=\"line\">\t\t\th2.insert(nums2[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;r;</span><br><span class=\"line\">\t\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = h2.begin();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(it != h2.end())<span class=\"comment\">//求交集</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!h1.insert(*it).second)</span><br><span class=\"line\">\t\t\t\tr.push_back(*it);</span><br><span class=\"line\">\t\t\tit++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode-Summary Ranges","url":"http://dreamwuhi.github.io/2016/05/29/Leetcode-Summary-Ranges/","content":"<p>本题给你一个已经排好序的整形数组（元素不会出现重复），求其中数字连续的片段。<br>例如：A[0,1,2,4,5,7],返回[“0-2”,”4-&gt;5”,”7”].</p>\n<p>本题思路：从头遍历一遍数组，如果a[i]+1 != a[i+1]，那么在a[i]与a[i+1]不连续，就输出a[start]-&gt;a[i]，其中start为开始的位置，提前记录下就好。<br>几个注意点：<br>1、如果连续片段只有一个数字，就只输出该数字，并非”数字-&gt;数字”<br>2、每次开始找连续片段前，可以提前判断下是否有丢失的数字，如果没有，就没必要遍历，直接可以返回。<br>例如：A[1,2,3,4,5] 因为，A[4]-A[0]+1 == A.size()。表示数组是连续的，没有数字丢失。因此就可以直接返回结果，节省时间。<br>3、整形数组，考虑它的范围<br>4、边缘条件：空数组，元素只要一个<br><a id=\"more\"></a><br>代码如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">ToString</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> r[<span class=\"number\">32</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(r,<span class=\"string\">\"%d\"</span>,n);</span><br><span class=\"line\">\t\treturn <span class=\"built_in\">string</span>(r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; summaryRanges(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums.empty()) return res;  <span class=\"comment\">//边缘条件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums.size() == <span class=\"number\">1</span>) \t\t</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tres.push_back(ToString(nums.front()));</span><br><span class=\"line\">\t\t\treturn res;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> cnt = nums.back() - nums.front() + <span class=\"number\">1</span> - nums.size();  <span class=\"comment\">//判断数组片段是否连续</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt == <span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tres.push_back(ToString(nums.front())+<span class=\"string\">\"-&gt;\"</span>+ToString(nums.back()));</span><br><span class=\"line\">\t\t\treturn res;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> startIndex , i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;nums.size() &amp;&amp; cnt != <span class=\"number\">0</span>;++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!flag)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tstartIndex = i;<span class=\"comment\">//记录每次开始寻找时的起始位置</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(nums.back() - nums[i] + <span class=\"number\">1</span> == nums.size() - i)<span class=\"comment\">//判断从该起始位置开始到数组末尾，是否为连续的数组</span></span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(nums[i] + <span class=\"number\">1</span> != nums[i+<span class=\"number\">1</span>])\t<span class=\"comment\">//相邻元素间判断</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(startIndex == i)</span><br><span class=\"line\">\t\t\t\t\tres.push_back(ToString(nums[startIndex]));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\tres.push_back(ToString(nums[startIndex])+<span class=\"string\">\"-&gt;\"</span>+ToString(nums[i]));</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\tcnt--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i&lt;nums.size()<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\t\tres.push_back(ToString(nums[i])+<span class=\"string\">\"-&gt;\"</span>+ToString(nums.back()));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tres.push_back(ToString(nums[i]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode-Integer Break","url":"http://dreamwuhi.github.io/2016/05/29/Leetcode-Integer-Break/","content":"<p>本题的题意是给定一个整数N，将其拆分为至少两个正数，且这些正数的和为N，求所有拆分种类中这些正数的乘积最大！<br>思路，枚举发现规律。<br>如下：7 = 3+2+2  F(7)=3^1 <em> 2^2 = 12<br>     8 = 3+3+2  F(8)=3^2 </em> 2^1 = 18<br>     9 = 3+3+3  F(9)=3^3 <em> 2^0 = 27<br>     10 = 3+3+2+2 F(10)=3^2 </em> 2^2 = 36<br>可以发现，N = 3a+2b,(a,b为数字3，数字2的个数)，F(N)=3^a+2^b。因此，可以先通过N/3求得有多少个3构成，如果余数为0，则没有数字2；余数为2，则有一个2；余数为1，则数字3减少1个，添加两个2（如10=3+3+3+1 转变成 3+3+2+2）。<br>最后考虑边缘条件，当N=2，N=3的情况。<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">integerBreak</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(n==<span class=\"number\">2</span>) return <span class=\"number\">1</span>;<span class=\"comment\">//边缘情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(n==<span class=\"number\">3</span>) return <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(n % <span class=\"number\">3</span> == <span class=\"number\">0</span>)\t\t<span class=\"comment\">//余数为0</span></span><br><span class=\"line\">\t\t\treturn (int)<span class=\"built_in\">pow</span>(<span class=\"number\">3.0</span>,n/<span class=\"number\">3</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n % <span class=\"number\">3</span> == <span class=\"number\">2</span>) <span class=\"comment\">//余数为2</span></span><br><span class=\"line\">\t\t\treturn (int)<span class=\"built_in\">pow</span>(<span class=\"number\">3.0</span>,n/<span class=\"number\">3</span>) * <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>\t\t\t\t<span class=\"comment\">//余数为1</span></span><br><span class=\"line\">\t\t\treturn (int)<span class=\"built_in\">pow</span>(<span class=\"number\">3.0</span>,n/<span class=\"number\">3</span><span class=\"number\">-1</span>) * <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"恒生面试","url":"http://dreamwuhi.github.io/2016/05/28/恒生面试/","content":"<p>周日笔试，周四收到电话通知，周五去面试。<br>面试的形式是一个部门经理，同时面两个学生。<br>和我主要聊了网络模型，其中的一个项目中的一些东西，操作系统，数据库，网络等的一些基础知识。<br>总体来说，恒生的面试偏简单，没有网易的复杂。而且，恒生这边还是蛮急用C/C++开发的。<br>不过比较遗憾的是，经理要求最好能够连续实习5-6个月，前两个月教你一些基础的业务，让你熟悉业务环境，基础技术。<br>后面就可以直接上手干项目。不过，由于我本人研究生，时间并没有那么多，所以去不成！！</p>\n"},{"title":"Leetcode-Minimum Height Trees","url":"http://dreamwuhi.github.io/2016/05/23/Leetcode-Minimum-Height-Trees/","content":"<p>本题给你一个无向图，其中有n个顶点，n-1条边，因此取其中的任意某顶点作为根，都可以构建成一棵树。那么本题的问题就是在这些树中找出高度最小的树，返回树的根节点；如果有多棵树的高度相同，则返回多个根节点。</p>\n<p>思路1：一开始，我认为最直白的解法就是遍历所有的顶点，以该顶点为根，求此树的高度。最后找出高度最小的树就是答案。此为暴力法，但是暴力一般往往会超时，本题也不例外。所以就得另辟蹊径咯。</p>\n<p>思路2：先找到所有的叶子节点(该顶点只与一个顶点连接，即只有一条边)，再删除所有的叶子节点，再继续找目前的叶子节点，再删除掉。直到找不到叶子节点为止。那么最后一次找到的叶子节点就是所求的根节点。这题算是trick吧，自己多画几个图，或许可以发现这个规律。</p>\n<p>好了，代码如下。<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; findMinHeightTrees(<span class=\"keyword\">int</span> n, <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;adj(n);</span><br><span class=\"line\">\t\t<span class=\"comment\">//构建邻接表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;edges.size(); ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> x = edges[i].first;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> y = edges[i].second;</span><br><span class=\"line\">\t\t\tadj[x].push_back(y);</span><br><span class=\"line\">\t\t\tadj[y].push_back(x);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//处理边缘条件</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;res;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(edges.size() == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tres.push_back(edges[<span class=\"number\">0</span>].first);</span><br><span class=\"line\">\t\t\tres.push_back(edges[<span class=\"number\">0</span>].second);</span><br><span class=\"line\">\t\t\treturn res;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(edges.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\treturn res;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找叶子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;adj.size(); ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(adj[i].size() == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\tres.push_back(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//删除叶子节点，再找叶子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; next;<span class=\"comment\">//保存叶子节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;res.size(); ++i)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> node = res[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//删除叶子节点</span></span><br><span class=\"line\">\t\t\t\tadj[adj[node][<span class=\"number\">0</span>]].erase(find(adj[adj[node][<span class=\"number\">0</span>]].begin(),adj[adj[node][<span class=\"number\">0</span>]].end(),node));</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(adj[adj[node][<span class=\"number\">0</span>]].size() == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t\tnext.push_back(adj[node][<span class=\"number\">0</span>]);<span class=\"comment\">//添加叶子节点</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(next.empty())<span class=\"comment\">//找不到叶子节点</span></span><br><span class=\"line\">\t\t\t\treturn res;\t<span class=\"comment\">//返回上一次找到的叶子节点</span></span><br><span class=\"line\">\t\t\tres = next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode-House Robber III","url":"http://dreamwuhi.github.io/2016/05/22/Leetcode-House-Robber-III/","content":"<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:<br>     3<br>    / \\<br>   2   3<br>    \\   \\<br>     3   1<br>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.<br>Example 2:<br>     3<br>    / \\<br>   4   5<br>  / \\   \\<br> 1   3   1<br>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n<p>本题是一道树形DP问题。<br>思路：<br>一颗二叉树可以返回两种结果，选取父节点的结果与未选取父节点的结果。<br>其中，选取了父节点，则左右孩子节点都不能被选取。即F0(root) = root-&gt;val + F1(root-&gt;left) + F1(root-&gt;right).<br>未选取父节点，则左右孩子节点可选可不选，视情况而定。<br>即F1(root) = max(F0(root-&gt;left),F1(root-&gt;left))+max(F0(root-&gt;right),F1(root-&gt;right)).<br>&lt;！–more–&gt;    </p>\n"},{"title":"Leetcode-Binary Tree Paths","url":"http://dreamwuhi.github.io/2016/05/21/Leetcode-Binary-Tree-Paths/","content":"<p>本题要求将二叉树所有的路径输出，是一道简单题，深度优先遍历即可。<br>二叉树节点存储的是Int值，需要将其转化为字符串。<br><a id=\"more\"></a><br>代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">i2s</span><span class=\"params\">(<span class=\"keyword\">int</span> val , <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;tmp)</span></span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span> pp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(val &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t    tmp += <span class=\"string\">\"-\"</span>;</span><br><span class=\"line\">\t\t    val = -val;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(val)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tpp.insert(pp.begin(), <span class=\"string\">'0'</span>+val % <span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\tval = val / <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttmp += pp + <span class=\"string\">\"-&gt;\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Traver</span><span class=\"params\">(TreeNode* root, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> tmp)</span> </span><br><span class=\"line\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(root)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\ti2s(root-&gt;val,tmp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(root-&gt;left)</span><br><span class=\"line\">\t\t\t\tTraver(root-&gt;left,tmp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(root-&gt;right)</span><br><span class=\"line\">\t\t\t\tTraver(root-&gt;right,tmp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttmp.erase(tmp.begin()+tmp.size()<span class=\"number\">-2</span>,tmp.end());</span><br><span class=\"line\">\t\t\t\tv.push_back(tmp);</span><br><span class=\"line\">\t\t\t&#125;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; binaryTreePaths(TreeNode* root) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> tmp;</span><br><span class=\"line\">        Traver(root,tmp);</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Leetcode-Palindrome Linked List","url":"http://dreamwuhi.github.io/2016/05/19/Leetcode-Palindrome-Linked-List/","content":"<p>今天看了ICPC-2016WF，瞬间又燃起了刷题的兴趣。研一的时候玩了好几个月，后来由于忙其它的东西就不怎么刷题了。</p>\n<p>这道题是判断链表是否是回文，需要0(N)时间复杂度，0(1)空间复杂度。<br>阶梯思路想到了比较简单，先翻转一半链表，再双指针判断即可。</p>\n<p>例如：链表的如下<br>1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1，总共有6个元素，可以翻转最后三个元素，得到1-&gt;2-&gt;3-&gt;1-&gt;2-&gt;3。<br>设定两个指针分别指向前半部分的起点与后半部分的起点，再依次比较节点上的元素是否相同即可。<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">struct</span> ListNode &#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">     ListNode *next;</span><br><span class=\"line\">     ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode* head)</span> </span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> cnt = GetLength(head);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == <span class=\"number\">1</span>) return <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        \tReverse(head,cnt/<span class=\"number\">2</span><span class=\"number\">-1</span>);</span><br><span class=\"line\">        \treturn Judge(head, cnt/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;\t</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        \tReverse(head,cnt/<span class=\"number\">2</span>);</span><br><span class=\"line\">        \treturn Judge(head,cnt/<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Judge</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> beg)</span></span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">    \tListNode* rightHead = head;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(beg--)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\trightHead = rightHead-&gt;next;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \tListNode* leftHead = head;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(leftHead &amp;&amp; rightHead)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(leftHead-&gt;val != rightHead-&gt;val)</span><br><span class=\"line\">    \t\t\treturn <span class=\"literal\">false</span>;</span><br><span class=\"line\">    \t\tleftHead = leftHead-&gt;next;</span><br><span class=\"line\">    \t\trightHead = rightHead-&gt;next;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \treturn <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetLength</span><span class=\"params\">(ListNode* head)</span></span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">size_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \tListNode* p = head;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\tcnt++;</span><br><span class=\"line\">    \t\tp = p-&gt;next;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \treturn cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reverse</span><span class=\"params\">(ListNode* head, <span class=\"keyword\">int</span> beg)</span></span><br><span class=\"line\">    </span>&#123;</span><br><span class=\"line\">    \tListNode* st = head;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(beg--)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\tst = st-&gt;next;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \tListNode* pre = st-&gt;next;</span><br><span class=\"line\">    \tListNode* cur = pre-&gt;next;</span><br><span class=\"line\">    \tListNode* tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">while</span>(cur)</span><br><span class=\"line\">    \t&#123;</span><br><span class=\"line\">    \t\tpre-&gt;next = cur-&gt;next;</span><br><span class=\"line\">    \t\ttmp = st-&gt;next;</span><br><span class=\"line\">    \t\tst-&gt;next = cur;</span><br><span class=\"line\">    \t\tcur-&gt;next = tmp;</span><br><span class=\"line\">    \t\tcur = pre-&gt;next;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"网易面试之Windows开发实习","url":"http://dreamwuhi.github.io/2016/04/14/网易面试之Windows开发实习/","content":"<p>今天完成了人生中的第一次正规面试，貌似来的真的太晚了。本人半路出家，本科四年只学过C语言，考研那会才真正开始踏入CS专业的道路。<br>研一刚进来的时候，那叫一个菜啊，真的菜。连VS2010才从研一的时候开始用，以前都用VC6.0，真是呵呵哒了。自己的研究方向是图像处理，啥都不知道，先从Opencv自学开始，自己慢慢地摸索，虽然进度很慢，但是到现在为止自己感觉真的是进步蛮大的。<br>研一，自学了数据结构，Leetcode刷了一大半，那时只剩30道左右没又刷了。自学了MFC,写了一个图书馆管理系统。积累了一些图形图像的基本知识及相关机器学习的算法。<br>研二，重点学了Linux,深入C++的理解，看了《C++ Primer》，《Effective C++》,&lt;&lt;深度探索C++对象模型&gt;&gt;，《C和指针》。<br>通过网易云课堂，看了很多择善教育的Win32编程视频，随后自己开始Windows编程的学习，主要看了《Windows程序设计》上下版，《Windows核心编程》<br>对了，最重要的是着重了解Duilib开源框架，这个是用C++，在Win32上封装的一个UI库。写界面真的是比用原生Win32或MFC开发简单了很多倍，重点还更漂亮！<br><a id=\"more\"></a><br>好了，以上大概就是我的学习经历，其实说实话，自己的知识面还是很窄的。对于网络，数据库，操作系统（略了解）都是很欠缺的，今天在面试的时候，这方面的内容我都回答不出来。接下来需要重点来学习下！！</p>\n<p>好了，说重点吧，今天的面试过程。<br>今天的面试分三轮，前两轮是技术面，最后一面是HR面，如果前两轮不好的话，就没有HR面了~~<br>博主今天很早就到了网易，打了个顺风车，在车上还使劲地看一些排序算法，面试一个都没问到，呵呵哒了~~<br>到了11点的时候终于轮到我面试了，面试官是一个比较年轻的小哥，我先简单的自我介绍，面试官看到我的项目上用了duilib,他就开始对duilib展开提问。<br>后来，才发现原来最近他们部门在重新邮件客户端，用的UI库就是这个，怪不得他一直问我这方面的问题，足足是一个小时啊。<br>首先，他问我对duilib了解，然后我就简单说了duilib的特点及其与原生Win32窗口程序开发的区别。说的比较浅，面试官不是很满意，然后他说duilib最大的特点应该是消息机制的实现，其实我知道是这个，但是我说不清具体怎么实现的，所以我也就没说。<br>第二个问题，他问我duilib的组织结构。<br>第三个问题，duilib xml的解析<br>第四个问题，EventSeletc模型的特点<br>第五个问题，客户端怎么处理服务器发送过来的数据交给UI线程<br>第六个问题，自定义的消息结构是怎么样的<br>第七个问题，当出现异常的消息内容，如何处理<br>第八个问题，一道算法题，大致内容是给我一段字符串，里面包括一些表情，一些文本，如何解析文本及表情，以及一些边界等特殊情况的处理。<br>第九个问题，如何高效的处理XML解析后，控件的创建<br>第十个问题，虚函数与重载的区别，及深层含义<br>一面大概就是这些问题。</p>\n<p>二面的时候，面试官也比较年轻。<br>一问，除了EnentSelect网络模型还了解什么模型，我答了IO重叠模型，和IOCP模型，然后重点分析了IOCP模型的过程及特点。面试官比较满意<br>二问，线程同步的机制<br>三问，智能指针<br>四问，智能指针auto_ptr的实现，手写！<br>五问，一道编程题，输出结果。重点考察的一个虚函数表的特性<br>六问，父类虚的析构函数的作用，以及把父类的析构函数都定义成虚函数会怎么样<br>七问，不让调用构造函数的方法<br>八问，数据与UI的交互<br>九问，设断点程序会停下来的原理<br>十问，貌似没了，我问了他两个问题就结束了。</p>\n<p>HR面，随便聊聊。。</p>\n<p>就这样，等结果了~~~</p>\n"},{"title":"数据结构-链表旋转","url":"http://dreamwuhi.github.io/2016/04/13/数据结构-链表旋转/","content":"<hr>\n<h1 id=\"链表旋转\"><a href=\"#链表旋转\" class=\"headerlink\" title=\"链表旋转\"></a>链表旋转</h1><p>链表旋转有指定一段旋转，也有整个链表旋转。我这边讲述下整个链表旋转，因为核心的思想都是一样的。</p>\n<h2 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h2><p>构建三个指针head,pre,cur。<br>其中，head-&gt;next指向我们待旋转链表的头结点。pre指向头结点。cur指向第二个结点。<br>每一次的操作都是一样的，如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmp = head-&gt;next;</span><br><span class=\"line\">pre-&gt;next = cur-&gt;next;</span><br><span class=\"line\">head-&gt;next = cur;</span><br><span class=\"line\">cur-&gt;next = tmp;</span><br><span class=\"line\">cur = pre-&gt;next;</span><br></pre></td></tr></table></figure></p>\n<p>理解了上面的核心代码，链表旋转就完成一大半了，剩下要做的就是让链表循环起来及一些边界条件的判断，如下<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> ListNode* next;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> n) : val(n) , next(<span class=\"literal\">NULL</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reserve</span><span class=\"params\">(ListNode* root)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!root || !root-&gt;next) return root;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ListNode* head = new ListNode(<span class=\"number\">-1</span>);  <span class=\"comment\">//新建一个结点指向我们待旋转链表的头结点</span></span><br><span class=\"line\">    head-&gt;next = root;</span><br><span class=\"line\">    ListNode* pre = root;</span><br><span class=\"line\">    ListNode* cur = root-&gt;next;</span><br><span class=\"line\">    ListNode* tmp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp = head-&gt;next;</span><br><span class=\"line\">        pre-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        head-&gt;next = cur;</span><br><span class=\"line\">        cur-&gt;next = tmp;</span><br><span class=\"line\">        cur = pre-&gt;next;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp = head-&gt;next;   </span><br><span class=\"line\">    <span class=\"keyword\">delete</span> head;\t\t<span class=\"comment\">//旋转完，释放新建的结点，防止内存泄露</span></span><br><span class=\"line\">    head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    return tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>关于链表的一些操作其实还是算简单的，只要搞清楚了链表结点之间的指向关系，一般都可以搞定~~</p>\n<hr>\n"},{"title":"多线程同步之内核模式","url":"http://dreamwuhi.github.io/2016/04/12/多线程同步之内核模式/","content":"<hr>\n<p>本文主要是对内核模式下的多线程机制进行讲述。与用户模式下的同步机制相比，使用内核对象的同步机制用途更加广泛。</p>\n<hr>\n<hr>\n<h1 id=\"内核对象包括以下几类\"><a href=\"#内核对象包括以下几类\" class=\"headerlink\" title=\"内核对象包括以下几类\"></a>内核对象包括以下几类</h1><ul>\n<li>进程</li>\n<li>线程</li>\n<li>作业</li>\n<li>事件</li>\n<li>可等待的计时器</li>\n<li>信号量</li>\n<li>互斥量</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"等待函数\"><a href=\"#等待函数\" class=\"headerlink\" title=\"等待函数\"></a>等待函数</h1><p>在使用内核对象的同步机制时，就要用到等待函数来判断内核对象是否已经触发，这样就可以确定调用线程是否可被调度。</p>\n<h2 id=\"WaitForSingleObject\"><a href=\"#WaitForSingleObject\" class=\"headerlink\" title=\"WaitForSingleObject\"></a>WaitForSingleObject</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">WaitForSingleObject</span><span class=\"params\">(HANDLE hObject, DWORD dwMilliseconds)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>hObject：表示要等待的内核对象</li>\n<li>dwMilliseconds：表示线程愿意花费多少时间来等待对象被触发（时间单位：毫秒），INFINITE表示无限等待  </li>\n<li><p>函数的返回值：如果线程等待的对象被触发了，则返回WAIT_object_0; 如果因为等待超时，返回WAIT_TIMEOUT; 如果给函数传入的是无限的句柄，则返回WAIT_FAILED;</p>\n<a id=\"more\"></a>\n<h2 id=\"WaitForMultipleObject\"><a href=\"#WaitForMultipleObject\" class=\"headerlink\" title=\"WaitForMultipleObject\"></a>WaitForMultipleObject</h2><p>与WaitForSingleObject不同之处，WaitForMultipleObject可以等待多个内核对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">WaitForMultipleObject</span><span class=\"params\">(</span><br><span class=\"line\">\t\tDWORD dwCount,</span><br><span class=\"line\">\t\tCONST HANDLE* phObjects,</span><br><span class=\"line\">\t\tBOOL  bWaitAll, </span><br><span class=\"line\">\t\tDWORD dwMilliseconds)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dwCount：等待内核对象的数量</p>\n</li>\n<li>phObjects：指针，指向内核对象句柄数组</li>\n<li>bWaitAll： TRUE,等待所有的内核对象都触发时才返回；FALSE，只要有一个内核对象触发就返回</li>\n<li>dwMilliseconds：表示线程愿意花费多少时间来等待对象被触发（时间单位：毫秒），INFINITE表示无限等待 </li>\n<li>WaitForMultipleObject的返回值：WAIT_TIMEOUT、WAIT_FAILED与WaitForSingleObject相同；如果设置的是任意一个内核对象触发就返回的话，则返回值是[WAIT_object_0,WAIT_object_0+dwCount-1]，得到的数值是内核句柄数组的一个索引；</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"事件内核对象\"><a href=\"#事件内核对象\" class=\"headerlink\" title=\"事件内核对象\"></a>事件内核对象</h1><p>事件内核对象包括一个使用计数，一个是否是自动重置事件还是手动重置事件的布尔值，以及另一个表示事件有没有被触发的布尔值。<br>手动重置事件被触发的时候，正在等待该事件的所有线程都讲变成可调度状态。<br>自动重置事件被触发的时候，只要一个正在等待该事件的线程会变成可调度状态。</p>\n<h2 id=\"事件内核对象的创建\"><a href=\"#事件内核对象的创建\" class=\"headerlink\" title=\"事件内核对象的创建\"></a>事件内核对象的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">CreateEvent</span><span class=\"params\">(</span><br><span class=\"line\">\t\tPSECURITY_ATTRIBUTES psa,</span><br><span class=\"line\">\t\tBOOL bManualReset,</span><br><span class=\"line\">\t\tBOOL bInitialState,</span><br><span class=\"line\">\t\tPCTSTR pszName)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>bManualReset:表示是否创建手动重置对象</li>\n<li>bInitialState:事件初始化为触发状态(TRUE)还是未触发状态(FALSE)</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">SetEvent</span><span class=\"params\">(HANDLE hEvent)</span></span>;<span class=\"comment\">//设置事件触发状态</span></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">ResetEvent</span><span class=\"params\">(HANDLE hEvent)</span></span>;<span class=\"comment\">//设置事件未触发状态</span></span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<h1 id=\"信号量内核对象\"><a href=\"#信号量内核对象\" class=\"headerlink\" title=\"信号量内核对象\"></a>信号量内核对象</h1><p>信号量内核对象用来对资源进行计数。包含一个使用计数，一个最大资源计数和一个目前资源使用计数。</p>\n<h2 id=\"信号量的规则：\"><a href=\"#信号量的规则：\" class=\"headerlink\" title=\"信号量的规则：\"></a>信号量的规则：</h2><ul>\n<li>如果当前资源计数大于0，那么信号量处于触发状态</li>\n<li>如果当前资源计数等于0，那么信号量处于未触发状态</li>\n<li>系统绝对不会让当前资源计数变为负数</li>\n<li>当前资源计数绝对不会大于最大资源计数</li>\n</ul>\n<h2 id=\"信号量内核对象的创建\"><a href=\"#信号量内核对象的创建\" class=\"headerlink\" title=\"信号量内核对象的创建\"></a>信号量内核对象的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">CreateSemaphore</span><span class=\"params\">(</span><br><span class=\"line\">\t\tPSECURITY_ATTRIBUTES psa,</span><br><span class=\"line\">\t\tLONG lInitialCount,</span><br><span class=\"line\">\t\tLONG lMaximumCount,</span><br><span class=\"line\">\t\tPCTSTR pszName)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>lMaximumCount: 资源的最大使用数量</li>\n<li>lInitialCount: 初始化时资源中有多少可以使用</li>\n</ul>\n<p>每当线程成功等待信号量内核对象，则会将当前使用计数减1，最后线程还要调用ReleaseSemaphore来递增信号量的当前资源使用计数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">ReleaseSemaphore</span><span class=\"params\">(HANDLE hSemaphore,LONG lReleaseCount,PLONG plRreviousCount)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//此函数把lReleaseCount的值加到信号量的当前资源计数上，plRreviousCount返回当前资源计数的原始值</span></span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<h1 id=\"互斥量内核对象\"><a href=\"#互斥量内核对象\" class=\"headerlink\" title=\"互斥量内核对象\"></a>互斥量内核对象</h1><p>互斥量内核对象用来确保一个一个线程独占对一个资源的访问。互斥量对象包含一个使用计数，线程ID，递归计数。<br>其中，线程ID用了标识当前占用互斥量的是系统中的哪一个线程，递归计数标识这个线程占用该互斥量的次数。</p>\n<h2 id=\"互斥量对象的规则：\"><a href=\"#互斥量对象的规则：\" class=\"headerlink\" title=\"互斥量对象的规则：\"></a>互斥量对象的规则：</h2><ul>\n<li>如果线程ID为0，那么该互斥对象不为任何线程所占用，它处于触发状态</li>\n<li>如果线程ID非零值，那么有一个线程已经占用了该互斥量，它处于未触发状态</li>\n</ul>\n<h2 id=\"互斥量对象的创建\"><a href=\"#互斥量对象的创建\" class=\"headerlink\" title=\"互斥量对象的创建\"></a>互斥量对象的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">CreateMutex</span><span class=\"params\">(</span><br><span class=\"line\">\t\tPSECURITY_ATTRIBUTES psa,</span><br><span class=\"line\">\t\tBOOL bInitialOwner,</span><br><span class=\"line\">\t\tPCTSTR pszName)</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>bInitialOwner: 互斥量对象的初始状态。FALSE,互斥量对象的线程ID为0，递归计数为0，处于触发状态。<br>互斥内核对象的一个特点：系统会检查当前线程的ID与互斥量内部记录的线程ID是否相同。如果ID一致，那么系统会让线程保持可调度状态，即使互斥量尚未触发。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">ReleaseMutex</span><span class=\"params\">(HANDLE hMutex)</span></span>;<span class=\"comment\">//释放互斥量，互斥量内部的线程ID置0，递归计数置0，互斥量变成触发状态</span></span><br></pre></td></tr></table></figure>\n<hr>\n"},{"title":"多线程同步","url":"http://dreamwuhi.github.io/2016/04/11/多线程同步/","content":"<hr>\n<p>本文主要讲了用户模式下的线程同步机制，用户模式下的同步最大的好处是速度快。此外还有内核状态下的同步机制将放在写一篇博客中讲述！</p>\n<h1 id=\"原子访问\"><a href=\"#原子访问\" class=\"headerlink\" title=\"原子访问\"></a><strong>原子访问</strong></h1><ul>\n<li>指的是一个线程在访问某个资源的<font color=\"red\">同时</font>能够保证没有其他线程会在同一时刻访问同一资源。<br>Interlocked系列的函数可以保证是原子操作。</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"高级线程同步\"><a href=\"#高级线程同步\" class=\"headerlink\" title=\"高级线程同步\"></a><strong>高级线程同步</strong></h1><ul>\n<li>当线程想要访问某一共享资源的时候，线程必须调用系统函数，将线程想要访问的东西作为参数传递给函数。如果操作系统检测到资源可以被访问，那么这个函数会立即返回。这样线程就编程可调度状态。如果无法访问该共享资源，那么系统会将线程切换到等待状态，使线程变得不可调度，从而避免线程浪费CPU的时间。</li>\n</ul>\n<hr>\n<hr>\n<h1 id=\"关键代码段\"><a href=\"#关键代码段\" class=\"headerlink\" title=\"关键代码段\"></a><strong>关键代码段</strong></h1><ul>\n<li>这种方式让多行代码以原子的方式对资源进行操控。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CRITICAL_SECTION g_cs \t<span class=\"comment\">//初始化关键代码段结构</span></span><br><span class=\"line\">InitializeCriticalSection(g_cs);    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">EnterCriticalSection(&amp;g_cs);    <span class=\"comment\">//进入关键代码段</span></span><br><span class=\"line\">...</span><br><span class=\"line\">LeaveCriticalSection(&amp;g_cs);    <span class=\"comment\">//离开关键代码段</span></span><br><span class=\"line\">DeleteCriticalSection(g_cs);    <span class=\"comment\">//删除</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a id=\"more\"></a></h2><h1 id=\"关键段与旋转锁\"><a href=\"#关键段与旋转锁\" class=\"headerlink\" title=\"关键段与旋转锁\"></a><strong>关键段与旋转锁</strong></h1><ul>\n<li>当线程试图进入一个关键段，但这个关键段正被另一个线程占用的时候，函数会立即把调用线程切换到等待状态。这意味着线程必须从用户模式切换到内核模式（消耗大约1000个CPU周期）。这个切换的开销非常大。在配有多处理器的机器中，当前占用资源的线程可能在另一个线程完全切换到内核状态前就释放了占用的资源。如果真发生这种情况，那么会消耗大量的CPU周期。<br>因此在关键代码段中加入旋转锁来解决此问题。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">InitializeCriticalSectionAndSpinCount</span><span class=\"params\">(PCRITICAL_SECTION pcs, DWORD dwSpinCount)</span></span>;<span class=\"comment\">//dwSpinCount 表示旋转锁循环的次数</span></span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<h1 id=\"Slim读-写锁\"><a href=\"#Slim读-写锁\" class=\"headerlink\" title=\"Slim读/写锁\"></a><strong>Slim读/写锁</strong></h1><ul>\n<li>SRWLock允许我们区分那些想要读取资源值的线程（读取者线程）和想要更新资源值的线程（写入者线程）。让所有读取者线程同一时刻访问资源是可行的，因为不会破坏数据。写入者线程应该独占资源的访问权，任何其他读取者线程与写入者线程都不允许访问该资源。这就是SRWLock锁的关不内容。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">InitializeSRWLock</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>;<span class=\"comment\">//初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//写入者线程访问</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">AcquireSRWLockExclusive</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//读</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">ReleaseSRWLockExclusive</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//释放</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取者线程访问</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">AcquireSRWLockShared</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//读</span></span><br><span class=\"line\"><span class=\"function\">VOID <span class=\"title\">ReleaseSRWLockShared</span><span class=\"params\">(PSRWLOCK SRWLock)</span></span>; <span class=\"comment\">//释放</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n"},{"title":"C++基础知识(1)","url":"http://dreamwuhi.github.io/2016/04/11/C++基础知识(1)/","content":"<h3 id=\"New和Delete\"><a href=\"#New和Delete\" class=\"headerlink\" title=\"New和Delete\"></a>New和Delete</h3><ul>\n<li><p>内置类型对象或未提供默认构造函数的类类型对象必须显示初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* a = new int;\t\t//a未初始化</span><br><span class=\"line\">int* b = new int();\t\t//b初始化为0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>delete后，应该将指针赋值为NULL，否则该指针成为“悬垂指针”，悬垂指针是指向曾经存放对象的内存，但该对象已经不再存在了。</p>\n</li>\n<li>C++保证：删除0值的指针是安全的</li>\n</ul>\n<h3 id=\"显示类型转换\"><a href=\"#显示类型转换\" class=\"headerlink\" title=\"显示类型转换\"></a>显示类型转换</h3><ul>\n<li><strong>调用方式：</strong> cast-name<type>(expression)</type></li>\n<li><p><strong>static_cast</strong><br>  编译器隐式的执行任何类型转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void* p = &amp;d;</span><br><span class=\"line\">double* dp = static_cast&lt;double*&gt;p;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dynamic_cast</strong></p>\n</li>\n<li><strong>const_cast</strong><br>  转换掉表达式的const性质</li>\n<li><strong>reinterpret_cast</strong><a id=\"more\"></a>\n<h3 id=\"类成员函数的重载\"><a href=\"#类成员函数的重载\" class=\"headerlink\" title=\"类成员函数的重载\"></a>类成员函数的重载</h3></li>\n</ul>\n<ul>\n<li>函数名相同，函数的参数不同，返回值可以不同。注意：基于成员函数是否为const,可以重载一个成员函数</li>\n</ul>\n<h3 id=\"类的inline函数\"><a href=\"#类的inline函数\" class=\"headerlink\" title=\"类的inline函数\"></a>类的inline函数</h3><ul>\n<li>编译器会自动展开函数的定义。注意点：一般函数的代码量很小，且该函数会被经常调用。同时，该函数的定义必须被调用它的源文件可见。通常，内联函数的定义是放在某公共头文件中。</li>\n</ul>\n<h3 id=\"类的成员使用类声明\"><a href=\"#类的成员使用类声明\" class=\"headerlink\" title=\"类的成员使用类声明\"></a>类的成员使用类声明</h3><ul>\n<li>只有当类的定义已经在前面出现过数据成员才能被指定为该类类型。如果该类型是不完全类型（即只声明未定义），那么数据成员只能是指向该类类型的指针或者是引用。</li>\n</ul>\n<h3 id=\"类的构造函数初始化\"><a href=\"#类的构造函数初始化\" class=\"headerlink\" title=\"类的构造函数初始化\"></a>类的构造函数初始化</h3><ul>\n<li>构造函数的初始化列表会在构造函数体内语句之前运行。</li>\n<li>如果没有显式初始化列表，那么对于类类型的成员变量使用该成员变量的默认构造函数初始化。对于内置类型或者是复合类型的成员变量根据对象是否为全局而定。（全局对象则会初始化，局部对象不会初始化）</li>\n<li><strong>注意</strong>：对于const成员变量或者是引用类型成员变量及没有默认构造函数的类类型成员变量必须在显式初始化列表。</li>\n</ul>\n<h3 id=\"构造函数的隐式转换\"><a href=\"#构造函数的隐式转换\" class=\"headerlink\" title=\"构造函数的隐式转换\"></a>构造函数的隐式转换</h3><ul>\n<li>一般只带一个参数的构造函数会出现隐式转换，或者是构造函数的第二参数带有默认值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t A()</span><br><span class=\"line\">\t &#123;&#125;</span><br><span class=\"line\">\t A(int a)</span><br><span class=\"line\">\t &#123;</span><br><span class=\"line\">\t\tnum = a;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint num;\t \t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">A a = 12 //隐式的调用构造函数，再调用复制构造函数</span><br><span class=\"line\">A b(12); //显示的调用构造函数</span><br></pre></td></tr></table></figure>\n<ul>\n<li>隐式转换一般会带来不好的影响，最好的处理方法是加上<strong>explicit</strong>关键字，指定构造函数不能隐式转换。</li>\n</ul>\n<h3 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h3><ul>\n<li>允许一个类将对其非公有成员的访问授予指定的函数或类</li>\n</ul>\n<h3 id=\"static类成员\"><a href=\"#static类成员\" class=\"headerlink\" title=\"static类成员\"></a>static类成员</h3><ul>\n<li>非static数据成员存在于类类型的每一个对象中。static数据成员独立于该类的任意对象而存在；每个static数据成员与类关联的对象，并不与类的对象关联。</li>\n<li>static成员函数只能访问static成员变量，不能直接使用非static成员变量。</li>\n</ul>\n<h3 id=\"复制构造函数\"><a href=\"#复制构造函数\" class=\"headerlink\" title=\"复制构造函数\"></a>复制构造函数</h3><ul>\n<li><p>调用时间</p>\n<ul>\n<li>根据另一个同类型的对象显示或者是隐式初始化一个对象</li>\n<li>复制一个对象，将它作为实参传给一个函数</li>\n<li>从函数返回时复制对象</li>\n<li><p>初始化顺序容器中的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;std::string&gt;(10);//先调用string的默认构造函数，再调用复制构造函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据元素初始化式初列表初始化数组元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a[] = &#123;std::string(&quot;abc&quot;),std::string(&quot;bca&quot;)&#125;;</span><br><span class=\"line\">//首先调用A中接受string形参的构造函数初始化一个临时对象，再调用A的复制构造函数初始化</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>具体例子</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string null_book = &quot;99999&quot;;//首先调用接受一个C风格字符串形参的构造函数，再调用复制构造函数</span><br><span class=\"line\">string empty_copy = string();//首先调用默认构造函数，再调用复制构造函数</span><br></pre></td></tr></table></figure>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><ul>\n<li>当类中含有指针成员的时候，不重写赋值构造函数，复制构造函数，析构函数的话，很容易使程序崩溃</li>\n<li><strong>原因：</strong> 编译器为我们合成的复制、赋值函数，都只是浅层拷贝，不是深层拷贝（指针指向同一个对象），因此往往会在析构的时候，出现异常。</li>\n<li><strong>解决方法1：</strong>定义智能指针，引入<strong>使用计数</strong>概念</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class U_Ptr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tfriend class HasPtr;</span><br><span class=\"line\">\tint *ip;</span><br><span class=\"line\">\tsize_t use;//使用计数</span><br><span class=\"line\">\tU_Ptr(int* p) : ip(p) , use(1) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~U_Ptr()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdelete ip;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class HasPtr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tHasPtr(int*p , int i) : ptr(new U_Ptr(p)) , val(i) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr(const HasPtr&amp; orig) : ptr(orig.ptr), val(orig.val) </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tptr-&gt;use++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr&amp; operator=(const HasPtr&amp; rhs)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t++rhs.ptr-&gt;use;</span><br><span class=\"line\">\t\tif(--ptr-&gt;use == 0)</span><br><span class=\"line\">\t\t\tdelete ptr;</span><br><span class=\"line\">\t\tptr = rhs.ptr;</span><br><span class=\"line\">\t\tval = rhs.val;</span><br><span class=\"line\">\t\treturn *this;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~HasPtr()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif(--ptr-&gt;use == 0)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdelete ptr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tU_Ptr *ptr;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>解决方法2”</strong>实现深层拷贝</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HasPtr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint* ptr;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tHasPtr(const int&amp; p, int i) : ptr(new int(p)) , val(i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr(const HasPtr&amp; orig) : ptr(new int(*orig.ptr)) , val(orig.val)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t//实现深拷贝</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHasPtr&amp; operator=(HasPtr&amp; rhs)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tptr = rhs.ptr;</span><br><span class=\"line\">\t\tval = rhs.val;</span><br><span class=\"line\">\t\treturn *this;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"protected成员\"><a href=\"#protected成员\" class=\"headerlink\" title=\"protected成员\"></a>protected成员</h3><ul>\n<li>基类的一些成员希望允许派生类访问但是禁止其他用户访问，对于这样的成员应使用受保护的访问标志</li>\n<li><strong>注意点：</strong>派生类只能通过派生类对象访问其基类的protected成员，派生类对其基类类型对象的protected成员没有特殊访问权限。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test_base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tTest_base()&#123;&#125;</span><br><span class=\"line\">\t~Test_base()&#123;&#125;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint pb;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint kk;</span><br><span class=\"line\">\t/* data */</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Test_sun : public Test_base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid fun(Test_sun&amp; t, Test_base&amp; base)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tt.pb = 1;  //派生类对象可以访问基类的protected成员</span><br><span class=\"line\">\t\tbase.pb = 1;//错误，基类类型的对象不能访问其protected对象</span><br><span class=\"line\">\t\tpb = 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"duilib开发QQ界面","url":"http://dreamwuhi.github.io/2016/04/10/duilib开发QQ界面/","content":""},{"title":"Windows程序设计基础","url":"http://dreamwuhi.github.io/2016/04/10/Windows程序设计基础/","content":"<h2 id=\"窗口程序创建的过程\"><a href=\"#窗口程序创建的过程\" class=\"headerlink\" title=\"窗口程序创建的过程\"></a>窗口程序创建的过程</h2><hr>\n<h3 id=\"创建窗口类\"><a href=\"#创建窗口类\" class=\"headerlink\" title=\"创建窗口类\"></a>创建窗口类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WNDCLASS wndclass;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"注册窗口类\"><a href=\"#注册窗口类\" class=\"headerlink\" title=\"注册窗口类\"></a>注册窗口类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RegisterClass(&amp;wndclass);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"创建窗口\"><a href=\"#创建窗口\" class=\"headerlink\" title=\"创建窗口\"></a>创建窗口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hwnd = CreateWindow(...);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"显示窗口\"><a href=\"#显示窗口\" class=\"headerlink\" title=\"显示窗口\"></a>显示窗口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ShowWindow(hwnd,iCmdShow);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"更新窗口\"><a href=\"#更新窗口\" class=\"headerlink\" title=\"更新窗口\"></a>更新窗口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UpdateWindow(hwnd);  <span class=\"comment\">//产生第一条WM_PATINT消息</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"消息循环\"><a href=\"#消息循环\" class=\"headerlink\" title=\"消息循环\"></a>消息循环</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(GetMessage(&amp;msg,NULL,<span class=\"number\">0</span>,<span class=\"number\">0</span>))  <span class=\"comment\">//获取消息，只要消息类型不为WM_QUIT，返回值是非零值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tTranslateMessgae(&amp;msg);     <span class=\"comment\">//翻译消息</span></span><br><span class=\"line\">\tDispatchMessage(&amp;msg);      <span class=\"comment\">//分发消息到窗口过程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<a id=\"more\"></a>\n<h3 id=\"窗口过程\"><a href=\"#窗口过程\" class=\"headerlink\" title=\"窗口过程\"></a>窗口过程</h3><p>窗口过程在处理消息时，必须返回0。窗口过程不予处理的所有消息应该被DefWindowProc函数处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LRESULT CALLBACK <span class=\"title\">WinProctor</span><span class=\"params\">(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SendMessage(...);<span class=\"comment\">//程序可以直接调用自己的窗口过程</span></span><br></pre></td></tr></table></figure>\n<p><strong>总结：窗口过程与一个窗口类相关联，窗口类是程序调用RegisterClass注册的。基于该类创建的窗口使用这个窗口过程来处理窗口的所有消息。Windows通过调用窗口过程来给窗口发送一个消息</strong></p>\n<hr>\n<h2 id=\"窗口消息\"><a href=\"#窗口消息\" class=\"headerlink\" title=\"窗口消息\"></a>窗口消息</h2><h3 id=\"WM-PAINT\"><a href=\"#WM-PAINT\" class=\"headerlink\" title=\"WM_PAINT\"></a>WM_PAINT</h3><p>该消息使得客户区域重绘，以下几种情况会导致客户区域重绘，即产生WM_PAINT消息。<br>1、UpdateWindow(hwnd);<br>2、放大或者是缩小窗口（窗口类风格具有CS_HREDRAW,CS_VREDRAW）。<br>3、窗口最小化后，再复原。<br>4、窗口被其他窗口覆盖后，再复原。<br>5、使用ScrollWindow或ScrollDC函数滚动客户区的一部分。<br>6、使用InvalidateRect或InvalidateRgn函数显示产生WM_PAINT消息。</p>\n<hr>\n<h3 id=\"WM-DESTROY\"><a href=\"#WM-DESTROY\" class=\"headerlink\" title=\"WM_DESTROY\"></a>WM_DESTROY</h3><p>该消息使得窗口清除关闭。一般在获取该消息后，添加PostQuitMessage(0); 即，在消息队列中添加一条WM_QUIT消息。上文提到，消息循环中当遇到WM_QUIT消息后，就退出循环，结束程序。</p>\n"},{"title":"duilib开发微信界面","url":"http://dreamwuhi.github.io/2016/04/10/duilib开发微信界面/","content":"<h2 id=\"采用Duilib开源框架开发PC端微信\"><a href=\"#采用Duilib开源框架开发PC端微信\" class=\"headerlink\" title=\"采用Duilib开源框架开发PC端微信\"></a>采用Duilib开源框架开发PC端微信</h2>"}]